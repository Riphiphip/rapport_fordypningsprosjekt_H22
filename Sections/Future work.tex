\section{Future work}
While the foundation of knowledge for the RVSDG dialect is close to complete and some implementation has been done, there is still work to do before the dialect is complete and usable.

\subsection{Completing representations} \label{sec:future-work:copleting-representations}
This work has mostly revolved around learning the ropes of MLIR, so there is still a lot to do when it comes to getting the RVSDG dialect implemented. The first thing that should be done is to make a few adjustments to the chosen representations. Currently, the system does not have generalized support for region arguments and the change discussed under \hyperref[sec:learnings]{"Learnings and reflections"} should be a better solution. The gamma-node will need to be updated with this new representation.

There is also the matter of state edges. For now, they can't be represented in the RVSDG dialect, so a suitable representation must be found. A possible solution would be to create an MLIR type to represent state. Stateful RVSDG operations can take an input and produce an output of this state type. This maintains the use of SSA-values to represent RVSDG edges and should be sufficient to perform any necessary analysis. To keep using stateful Ops from other dialects as simple RVSDG nodes, some sort of shim layer would be required. The simplest solution would probably be to add a "wrapper"-Op that has the same signature as the stateful Op, with the addition of state inputs and a state output. Another solution would of course be to disallow these Ops before lowering the structural nodes from the RVSDG dialect.

Lambda- and delta-nodes behave differently to the other nodes in regard to output. Instead of outputting a tuple of values, they instead output a reference to themselves. Two solutions for this problem have been identified. The first one is to use MLIR's symbol table \cite{mlir_symbol_table}. Symbols and symbol tables are a non-SSA mechanism for referencing a specific Op using a name. This is how the default "func" dialect references functions \cite{mlir_func_dialect}. It is however not a great fit for the RVSDG dialect, as it breaks the representation of edges as SSA values. Another solution is to take the same approach as with states. Values passed as operands to MLIR Ops keep a reference to the Op that defined them. Creating types for lambda- and delta-node references would let the lambda- and delta-nodes output SSA values of these types. These values could then be passed around in accordance with the previously established representations. 

\subsection{Making the dialect usable}
Getting the previous points implemented should be sufficient to continue work on the remaining structural nodes. Once those are in place, there are still several things left to do before the RVSDG dialect can be useful for an actual compiler. How the following points are prioritized depends on which attributes of the dialect are most interesting to investigate. The most important step to create a functional compiler would be to lower RVSDG to a set of other dialects. No effort has yet been put into identifying suitable target dialects or getting to know the infrastructure surrounding lowering, so this step will probably take a lot of time and effort. Another closely related thing that needs to be done is creating a compiler frontend that uses the RVSDG dialect as an IR. The easiest way to do this would probably be to add the RVSDG dialect as a backend for the JLM compiler \cite{reissmann_github_2022}. Since the JLM compiler consumes LLVM IR, the compilation pipeline would end up having a decent amount of redundancy, but as a proof of concept it should still be fine.

For the RVSDG dialect to actually be useful, it should also be able to perform optimizations. The RVSDG paper outlines Common Node Elimination and Dead Node Elimination as candidates for implementation~\cite{Reissmann2020}. JLM also implements some other optimizations that can be considered, but CNE and DNE should be good starting points for getting familiar with the MLIR optimization infrastructure.

% Something about how I should probably make a standalone dialect instead of in-tree.
\subsection{Improving project structure}
As mentioned earlier, the choice of an in-tree dialect may not have been optimal in the long term. Because of this, I have decided to migrate the project to a standalone structure. There are no plans yet to perform an upmerge to MLIR to make the RVSDG dialect one of the default dialects, so it makes more sense to keep the dialect separate. This will make file-tree navigation faster and easier. It will probably decrease incremental build times by a decent amount since MLIR will no longer need to be rebuilt, only linked in.

\subsection{Evaluation} % I can do more here
Once everything is implemented and working, the solution should be evaluated. There are several key factors that are relevant for evaluating the MLIR dialect. Compilation overhead, binary performance, and usability are probably the most important ones, but this has yet to be given a lot of thought.
